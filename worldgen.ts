"use strict";

import { createNeighborDeltas, SQUARE8 } from "./geometry";

export type RGBA = [number, number, number, number]
export type ShowMapF = (value: number, index: number) => RGBA

export function lerp(a: number, b: number, n: number) {
    return a * (1 - n) + b * n;
}

export function clamp(a: number, b: number, n: number) {
    return n < a ? a : n > b ? b : n;
}

export function lerpRGBA(a: RGBA, b: RGBA, n: number): RGBA {
    if (!b)
        return [0, 0, 0, 0];
    return [0, 1, 2, 3].map(i => lerp(a[i], b[i], n)) as RGBA;
}


export let randomSeed = 6;
export function setSeed(n: number) {
    randomSeed = n
}

export type XY = [number, number];
export type Numbers = number[] | Float32Array;

export function random() {
    let x = Math.sin(randomSeed) * 10000;
    randomSeed = (randomSeed + Math.E) % 1e8;
    return x - Math.floor(x);
}

export function spread(range: number) {
    return range * (random() - 0.5);
}

export function coord2ind([x, y]: XY, width: number) {
    return Math.floor(x) + Math.floor(y * width);
}

export function context2d(canvas: HTMLCanvasElement) {
    return canvas.getContext("2d") as CanvasRenderingContext2D;
}

/** Creates canvas of the required size and returns it and it's 2d context. */
export function createCanvasCtx(width: number, height: number) {
    let canvas = document.createElement("canvas");
    canvas.width = width;
    canvas.height = height;
    let ctx = context2d(canvas);
    return { canvas, ctx };
}

/** Returns alpha channel of the image as numbers in 0-255 range. */
export function image2alpha(canvas: HTMLCanvasElement) {
    let ctx = context2d(canvas);
    let idata = ctx.getImageData(0, 0, canvas.width, canvas.height);
    let data = idata.data;
    let values = new Float32Array(data.length / 4);
    for (let i = 0; i < data.length; i++) values[i] = data[i * 4 + 3] / 255;

    return values;
}

/** Gradient noise generated by throwing ellipses at the plane. */
export function gradientNoise(
    width: number,
    height: number,
    points = 5000,
    radius = 100,
    alpha = 0.01,
    gradientCircles = true
) {
    let { canvas, ctx } = createCanvasCtx(width, height);

    if (gradientCircles) {
        let g = ctx.createRadialGradient(0, 0, 0, 0, 0, 1);
        g.addColorStop(0, `rgba(255, 255, 255, ${alpha})`);
        g.addColorStop(1, `rgba(255, 255, 255, 0)`);

        ctx.fillStyle = g;
    } else {
        ctx.fillStyle = `rgba(255, 255, 255, ${alpha})`;
    }

    for (let i = 0; i < points; i++) {
        let points = [...Array(3)].map(() => random());

        let [x, y] = [points[0] * width, points[1] * height];
        let r = Math.pow(points[2], 2) * radius;

        ctx.save();
        ctx.translate(x, y);
        ctx.rotate(random() * Math.PI);
        ctx.scale(r * (0.5 + random()), r * (0.5 + random()));
        ctx.beginPath();
        ctx.arc(0, 0, 1, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
    }

    return canvas;
}

function addFilter(srcCanvas, filter) {
    let { canvas, ctx } = createCanvasCtx(srcCanvas.width, srcCanvas.height);
    ctx.filter = filter;
    ctx.drawImage(srcCanvas, 0, 0);
    return canvas;
}

/** Monte-Carlo approximation of the quantile */
function approximateQuantile(values: Numbers, level = 0.5, picks = 1000) {
    if (!values)
        debugger;
    let l = values.length;
    let picked = [...Array(picks)].map(() => values[Math.floor(random() * l)]);
    picked = picked.sort();
    return picked[Math.floor(level * picked.length)];
}

export interface Arr {
    length: number;
    map: Function
}

function normalizeValues<T extends Arr>(values: T, picks = 1000): T {
    let l = values.length;
    let picked = [...Array(picks)].map(() => values[Math.floor(random() * l)]);
    let max = 0;
    for (let v of picked) if (v > max) max = v;
    return values.map((v) => v / max);
}

export type MapParams = {
    width: number
    height: number
    seed: number
    noiseSeed: number
    elevationCold: number
    seaRatio: number
    flatness: number
    noiseSmoothness: number
    tectonicSmoothness: number
    noiseFactor: number
    crustFactor: number
    tectonicFactor: number
    averageTemperature: number
    biomeScrambling: number
    pangaea: number
    erosion: number
    riversShown: number
    randomiseHumidity: number
    generatePhoto: boolean
    shading: boolean
}

export type LayeredMap = {
    dryElevation: Float32Array;
    tectonic: Float32Array;

    elevation: Float32Array;
    noise: Float32Array;
    rivers: Float32Array;
    wind: Float32Array;
    temperature: Float32Array;
    humidity: Float32Array;
    biome: Float32Array;
    photo: RGBA[];
}

const gen = ({ width, height }, smoothness: number, points, radius, alpha) =>
    image2alpha(addFilter(gradientNoise(width, height, points,
        Math.sqrt(width * width + height * height) * radius, alpha),
        `blur(${smoothness}px)`))


export type Terrain = { dryElevation: Float32Array, tectonic: Float32Array };

export function generateTerrain(params: MapParams) {
    let {
        width,
        height,
        seed,
        noiseSmoothness,
        tectonicSmoothness,
        noiseFactor,
        crustFactor,
        tectonicFactor,
        pangaea,
    } = params;

    randomSeed = seed;

    const mapSize = width * height;

    console.time("noise");

    let noise = gen(params, noiseSmoothness, 3000, 0.15, 0.03);

    let crust = gen(params, tectonicSmoothness, 2000, 0.15, 0.03);

    let tectonicMul = gen(params, tectonicSmoothness, 2000, 0.15, 0.03);

    console.timeEnd("noise");

    console.time("main");

    let tectonicMedian = approximateQuantile(crust, 0.5);

    let tectonic = crust.map(
        (v, i) => {
            let t = (0.2 / (Math.abs(tectonicMedian - v) + 0.1) - 0.95) * (tectonicMul[i] - 0.2) * 2
            let fold = t * (1 + Math.sin((t ** 2)));
            fold = 0.5 * (noise[i] ** 2 - 0.2) * fold ** 2
            t += fold;
            return t;
        }
    );

    let elevationFloats = crust.map(
        (_, i) =>
            5 +
            noise[i] * noiseFactor +
            crust[i] * crustFactor +
            tectonic[i] * tectonicFactor +
            -pangaea *
            (Math.abs(i / mapSize - 0.5) + Math.abs((i % width) / width - 0.5))
    );

    console.timeEnd("main");

    console.time("normalize");

    let dryElevation = normalizeValues(elevationFloats);

    console.timeEnd("normalize");

    return { dryElevation, tectonic } as Terrain;
}

export function generateMap(params: MapParams, terrain?: Terrain): LayeredMap {
    terrain ??= generateTerrain(params);
    let lm = generateAtmosphere(params, terrain);
    return lm;
}

function generateAtmosphere(params: MapParams, terrain: Terrain) {
    let {
        width,
        height,
        averageTemperature,
        biomeScrambling,
        erosion,
        riversShown,
        randomiseHumidity,
        generatePhoto,
        shading,
        noiseSmoothness,
        seaRatio,
        flatness,
        noiseSeed,
        elevationCold
    } = params;

    randomSeed = noiseSeed

    let noise = gen(params, noiseSmoothness, 3000, 0.15, 0.01);

    let { dryElevation, tectonic } = terrain;
    const mapSize = width * height;

    let seaLevel = approximateQuantile(dryElevation, seaRatio);

    let elevation = dryElevation.map((v, i) =>
        v < seaLevel
            ? -Math.pow(1 - v / seaLevel, 0.35)
            : Math.pow(
                ((v - seaLevel) * (0.5 + tectonic[i] * 0.5)) / (1 - seaLevel),
                1 + 2 * flatness
            )
    );

    let rivers = generateRiversAndErosion({
        width,
        height,
        elevation,
        tectonic,
        erosion,
        riversShown,
    });

    //let noise = gen(params, noiseSmoothness, 3000, 0.15, 0.01);

    let wind = elevation.map(
        (h, i) =>
            Math.cos((Math.abs(0.5 - i / mapSize) * 4 + 0.85) * Math.PI) /
            (h < 0 ? 1 : 1 + 5 * h * h)
    );

    console.time("windSmoothing");
    wind = image2alpha(
        addFilter(
            data2image(wind, width, (v) => [0, 0, 0, 127 * (v + 1)]),
            "blur(3px)"
        )
    ).map((v) => v * 2 - 1);
    console.timeEnd("windSmoothing");

    let humidity = generateHumidity({ width, height, elevation, wind, steps: 400 });

    if (randomiseHumidity) {
        humidity = humidity.map((v, i) =>
            Math.max(0, v + Math.sin(noise[i] * 50) / 10 - elevation[i] * 0.2)
        );
    }

    let temperature = elevation.map(
        (e, i) =>
            averageTemperature +
            25 -
            (100 * Math.abs(0.5 - i / mapSize)) / (0.7 + 0.6 * humidity[i]) -
            Math.max(0, e) * elevationCold
    );

    //humidity = humidity.map((w, i) => w * (1 + Math.atan(-temperature[i] / 100)));

    console.time("biome");
    let biome = temperature.map((t, i) => {
        let scramble = (1 + biomeScrambling * Math.sin(noise[i] * 100));
        let b =
            biomeTable[
            Math.floor(
                Math.max(
                    0,
                    Math.min(
                        humidity[i] *
                        4.5 *
                        scramble,
                        5
                    )
                )
            )
            ][Math.floor(Math.max(0, Math.min(t * scramble / 10 + 1, 3)))] || 0;
        if (b == TUNDRA && elevation[i] > 0.5) b = MOUNTAIN;
        return b;
    });
    console.timeEnd("biome");
    let folds = [...humidity], shades = [...humidity];

    /**@type {number[][]} */
    let photo;
    if (generatePhoto) {
        console.time("photo");

        let rgba: RGBA;

        function lerpTo(b: number[], n: number) {
            for (let i of [0, 1, 2])
                rgba[i] = lerp(rgba[i], b[i], n);
        }

        photo = [...humidity].map((hum, i) => {
            let ele = elevation[i];
            if (ele < 0) {
                //return [0, (1 + ele * 2) * 55 + 30, (1 + ele * 2) * 155 + 50, 255];
                return [- (ele ** 2) * 1000 + 100, -(ele ** 2) * 500 + 150, -(ele ** 2) * 300 + 150, 255];
            } else {
                rgba = [
                    Math.max(0, temperature[i] * 15 - hum * 1000),
                    150 - hum * 100,
                    Math.max(0, temperature[i] * 8 - hum * 500),
                    255,
                ] as RGBA;

                //rgba = [128, 128, 128, 255];


                let et = (ele + tectonic[i]) * 2 - 1;

                if (et > 0) {
                    lerpTo([64, 0, 0, 255], Math.min(1.5, et ** 2 * (0.5 + random())));
                }

                /*let fold = tectonic[i] * (1 + Math.sin(tectonic[i] * 500));
                fold = clamp(0, 1, 2 * ((noise[i] - 0.3) * 20) * fold ** 2 * (0.5 + random())) * 5;
                lerpTo([0, 0, 0], fold);

                folds[i] = 0;*/

                if (temperature[i] < 0) {
                    //rgba = lerpRGBA(rgba,[255,255,255,255],0.5);
                    rgba = [255, 255, 255, 255];
                }

                if (rivers[i]) {
                    return [0, 100, 150 + 100 * ele, 255];
                }

                /**Shading */
                if (true) {
                    /*for (let j = 0; j < 3; j++) {
                        rgba[j] +=
                            50 +
                            -ele * 140 +
                            25 *
                            Math.atan(
                                120 *
                                ((elevation[
                                    i + width * (i > (width * height) / 2 ? 1 : -1)
                                ] || 0) -
                                    ele)
                            );
                    }*/
                    let shade = (elevation[i + width + 1] * 2 - elevation[i - width - 1] - ele)
                    lerpTo([0, 0, 0], clamp(-0.2, 0.2, shade * 5))
                    shades[i] = shade
                }

                //console.log([...rgba]);
                for (let d of [1, width, -1, -width, 0]) {
                    lerpTo(biomeColors[biome[i + d]], 0.1);
                }

                if (ele > 0 && (elevation[i + 1 + width * 1] < 0))
                    lerpTo([255, 255, 255, 255], 0.3);

                if (ele > 0 && (elevation[i - 1 - width * 1] < 0))
                    lerpTo([0, 0, 0, 255], 0.3);


                //console.log(rgba, biomeColors[biome[i]]);

                /*if (ele > 0 && ele < 0.0005) {
                    lerpTo([128, 255, 0, 255], 0.5);
                }*/

                /*let [a, b, c] = [-1, -width, 0].map(d => ~~(elevation[i + d] / 0.2));
                if (c != a || c != b)
                    lerpTo([0, 0, 0, 255], 0.1);

                if ((~~(i/width) + i)%4 == 0 && ele>0.2
                || (~~(i/width) - i)%4 == 0 && ele>0.4
            ) {
                    //let e = 100 - ~~(ele / 0.2) * 100;
                    let e = 0;
                    lerpTo([e, e, e, 255], 0.2);
                }*/

                //if(ele>0.2)  rgba = lerpRGBA(rgba, [128, 0, 128, 255], 0.5);

                return rgba;
            }
        });
        console.timeEnd("photo");
    }

    let layeredMap = {
        tectonic,
        dryElevation,
        elevation,
        noise,
        rivers,
        wind,
        temperature,
        humidity,
        biome,
        folds,
        photo,
        shades
    } as LayeredMap;

    return layeredMap;
}


function generateHumidity({ width, height, elevation, wind, steps }) {
    console.time("humidity");
    const mapDiagonal = Math.sqrt(width * width + height * height);

    let border = width / 2;

    let humidityImage = data2image(elevation, width, (v: number, i) => [
        0,
        0,
        0,
        v <= 0 ? 100 : 0,
    ]);
    let wetness = createCanvasCtx(width + border * 2, height + border * 2);

    wetness.ctx.beginPath();
    wetness.ctx.rect(border / 2, border / 2, width + border, height + border);
    wetness.ctx.lineWidth = border / 2;
    wetness.ctx.stroke();

    wetness.ctx.drawImage(humidityImage, width / 2, height / 2);

    wetness.ctx.filter = "opacity(50%)";
    const spotSize = mapDiagonal / 10;

    for (let i = 0; i < steps; i++) {
        let start: XY = [(i % 100 / 100) * width, (i % 10 / 10) * height];
        let windThere = wind[coord2ind(start, width)];
        let end = [
            start[0] + (windThere * 0.3 * width) / 8,
            start[1] + (Math.abs(windThere) * 0.5 * height) / 12,
        ];
        wetness.ctx.drawImage(
            wetness.canvas,
            start[0] + border,
            start[1] + border,
            spotSize,
            spotSize,
            end[0] + border,
            end[1] + border,
            spotSize,
            spotSize
        );
    }

    context2d(humidityImage).filter = "blur(10px)";
    context2d(humidityImage).drawImage(
        wetness.canvas,
        border,
        border,
        width,
        height,
        0,
        0,
        width,
        height
    );

    let humidity = image2alpha(humidityImage);

    console.timeEnd("humidity");

    return humidity;
}

type RiversParams = { width: number, height: number, elevation: Numbers, humidity?: Numbers, tectonic: Numbers, erosion: number, riversShown: number };

function generateRiversAndErosion({
    width,
    height,
    elevation,
    humidity,
    tectonic,
    erosion,
    riversShown,
}: RiversParams) {
    console.time("rivers");

    let rivers = new Float32Array(width * height);

    let neighbors = createNeighborDeltas(width, SQUARE8)[0];

    for (
        let streamIndex = 0;
        streamIndex < erosion + riversShown;
        streamIndex++
    ) {
        let current = Math.floor(random() * width * height);
        if (elevation[current] < random()) continue;

        if (humidity && humidity[current] < random()) continue;

        let limit = 10000;

        while (elevation[current] > -0.15 && limit-- > 0) {
            if (streamIndex > erosion) {
                rivers[current] += 1;
            }
            let currentElevation = elevation[current];

            let lowestNeighbor = 0,
                lowestNeighborElevation = 100;

            for (let neighborIndex = 0; neighborIndex < 8; neighborIndex++) {
                let neighborDelta = neighbors[neighborIndex];
                if (elevation[current + neighborDelta] <= lowestNeighborElevation) {
                    lowestNeighbor = current + neighborDelta;
                    lowestNeighborElevation = elevation[lowestNeighbor];
                }
            }

            if (lowestNeighborElevation < currentElevation) {
                elevation[current] -= (currentElevation - lowestNeighborElevation) / 5;
                //if (rivers[lowestNeighbor]) limit -= 10;
            } else {
                elevation[current] = lowestNeighborElevation + 0.02;
            }

            current = lowestNeighbor;
        }
    }

    console.timeEnd("rivers");

    return rivers;
}

export const DESERT = 1,
    GRASSLAND = 2,
    TUNDRA = 3,
    SAVANNA = 4,
    SHRUBLAND = 5,
    TAIGA = 6,
    DENSE_FOREST = 7,
    TEMPERATE_FOREST = 8,
    RAIN_FOREST = 9,
    SWAMP = 10,
    SNOW = 11,
    STEPPE = 12,
    CONIFEROUS_FOREST = 13,
    MOUNTAIN = 14,
    BEACH = 15;

// -> temperature V humidity
export const biomeTable = [
    [TUNDRA, STEPPE, SAVANNA, DESERT],
    [TUNDRA, SHRUBLAND, GRASSLAND, GRASSLAND],
    [SNOW, SHRUBLAND, GRASSLAND, TEMPERATE_FOREST],
    [SNOW, CONIFEROUS_FOREST, TEMPERATE_FOREST, TEMPERATE_FOREST],
    [TAIGA, CONIFEROUS_FOREST, DENSE_FOREST, DENSE_FOREST],
    [TAIGA, CONIFEROUS_FOREST, DENSE_FOREST, RAIN_FOREST],
];

export const biomeNames = [
    "unknown",
    "desert",
    "grassland",
    "tundra",
    "savanna",
    "shrubland",
    "taiga",
    "tropical forest",
    "decidious forest",
    "rain forest",
    "swamp",
    "snow",
    "steppe",
    "coniferous forest",
    "mountain shrubland",
    "beach",
];

export function mapToList(m) {
    let l = [];
    for (let k in m) {
        l[k] = m[k];
    }
    return l;
}

export function colorFromRGBString(color) {
    let n = parseInt(color, 16);
    return [Math.floor(n / 65536), Math.floor(n / 256) % 256, n % 256, 256];
}

export function colorFromRGB16String(color) {
    let n = parseInt(color, 16);
    let c = [Math.floor(n / 256) * 16, Math.floor(n / 16) % 16 * 16, n % 16 * 16, 256];
    return c;
}


export const biomeColors = mapToList({
    [DESERT]: "ff0",
    [GRASSLAND]: "8f8",
    [TUNDRA]: "cca",
    [SAVANNA]: "cc0",
    [SHRUBLAND]: "ad4",
    [TAIGA]: "064",
    [DENSE_FOREST]: "080",
    [TEMPERATE_FOREST]: "4a4",
    [RAIN_FOREST]: "084",
    [SWAMP]: "880",
    [SNOW]: "fff",
    [STEPPE]: "cfa",
    [CONIFEROUS_FOREST]: "0a4",
    [MOUNTAIN]: "844",
    [BEACH]: "ffd",
}).map(colorFromRGB16String) as RGBA[];

/**
 * Convert data to image according to callback function
 * @param {any[]} values
 * @param {number} width
 * @param {(v:number, i:number) => [number,number,number,number]} converter
 * @returns {HTMLCanvasElement}
 */

export function data2image<T>(values: ReadonlyArray<T> | Float32Array, width: number, converter: (v: T, i: number) => number[], altitudes?: (number) => number) {
    let height = values.length / width;
    let { canvas, ctx } = createCanvasCtx(width, height);
    let idata = ctx.createImageData(width, height);
    if (!idata.data || !values)
        debugger;
    for (let i = 0; i < values.length; i++) {
        let h: number = 0;
        let v = converter(values[i] as T, i) ?? 0;
        idata.data.set(v, i * 4);
        /*if (altitudes) {
            h = altitudes(i);
            for (let d = 0; d <= h; d++) {
                let ih = (i - d * width) * 4;
                if (ih >= 0 && ih < idata.data.length - 4) {
                    if (d == h)
                        idata.data.set(v, ih);
                    else
                        idata.data.set([64, 0, 0, 255], ih);
                }
            }
        } else {
            idata.data.set(v, i * 4);
        }*/
    }
    ctx.putImageData(idata, 0, 0);
    return canvas;
}

/**
 * Returns elevation image with higher elevation being brighter
 */
export function elevation2Image(
    { elevation, rivers },
    {
        discreteHeights = 10,
        terrainTypeColoring = false,
        hillRatio = 0.1,
        mountainRatio = 0.02,
        green = true,
    }
) {
    let hillElevation = approximateQuantile(elevation, 1 - hillRatio);
    let mountainElevation = approximateQuantile(elevation, 1 - mountainRatio);

    return ((v, i) => {
        if (rivers[i] && v > 0) {
            return [0, v * 400, 200, 255];
        }

        let level = discreteHeights
            ? Math.floor(v * discreteHeights) / discreteHeights
            : v;

        if (v > 0) {
            if (terrainTypeColoring)
                return v < hillElevation
                    ? [32, 128, 32, 255]
                    : v < mountainElevation
                        ? [196, 196, 32, 255]
                        : [128, 32, 0, 255];
            else
                return green
                    ? [level * 400, level * 150 + 100, 50, 255]
                    : [250 - level * 300, 200 - level * 300, 0, 255];
        } else {
            return [0, level * 60 + 60, level * 80 + 100, 255];
        }
    }) as ShowMapF;
}

/**
 * Returns canvas rescaled to the new size
 * @param {HTMLCanvasElement} source
 * @param {number} width
 * @param {number} height
 * @returns {HTMLCanvasElement}
 */
export function rescaleImage(source, width, height) {
    let { canvas, ctx } = createCanvasCtx(width, height);
    ctx.drawImage(source, 0, 0, source.width, source.height, 0, 0, width, height);
    return canvas;
}

/** Returns canvas that is a fragment of the source canvas */
export function subImage(image: HTMLCanvasElement, left: number, top: number, width: number, height: number) {
    let { canvas, ctx } = createCanvasCtx(width, height);
    ctx.drawImage(image, left, top, width, height, 0, 0, width, height);
    return canvas;
}

/**
 * Returns a matrix of rivers sizes and directions per cell
 * @param {number[]} heights
 * @param {number[]} neighborDeltas
 * @returns {number[]}
 */
export function generatePrettyRivers(heights, probability, attempts, neighborDeltas, columns) {
    let hlen = heights.length;
    let courseAt = 0;
    let course = new Int32Array(100);
    let riverDepth = new Int32Array(hlen);
    let flowsTo = new Int32Array(hlen);
    for (let riveri = 0; riveri < attempts; riveri++) {
        let at = Math.floor(random() * hlen);
        if (heights[at] <= 0 || probability[at] < random()) continue;
        courseAt = 0;
        while (heights[at] > 0 && courseAt < 100) {
            let row = Math.floor(at / columns);
            let lowestNeighborDelta = neighborDeltas[row % 2].reduce((a, b) =>
                heights[at + a] - riverDepth[at + a] <
                    heights[at + b] - riverDepth[at + b]
                    ? a
                    : b
            );
            if (heights[at + lowestNeighborDelta] >= heights[at]) break;
            at = at + lowestNeighborDelta;
            course[courseAt++] = at;
        }
        if (courseAt > 2 && heights[at] <= 0) {
            for (let i = 0; i < courseAt; i++) {
                riverDepth[course[i]]++;
                flowsTo[course[i]] = course[i + 1];
            }
        }
    }
    return { riverDepth, flowsTo };
}